package edu.duke.cs.osprey.sparse;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import edu.duke.cs.osprey.astar.conf.RCs;
import edu.duke.cs.osprey.confspace.ConfSpace;
import edu.duke.cs.osprey.confspace.RCTuple;
import edu.duke.cs.osprey.confspace.SearchProblem;
import edu.duke.cs.osprey.energy.EnergyFunction;
import edu.duke.cs.osprey.tools.ResidueIndexMap;

/**
 * This class is a container for the branch-decomposition and the corresponding subproblems 
 * generated by said branch-decomposition.
 * @author JJ
 *
 */
public class BranchDecomposedProblem {
	private Subproblem root;
	private TreeEdge sparseTree;
	private PartialConformationEnergyFunction sparseEnergyFunction;
	
	//Branch-decomposed problems require a map from PDBIndex to designIndex
	private ResidueIndexMap resMap;
	
	
	public BranchDecomposedProblem(SearchProblem problem, TreeEdge rootEdge, RCs fullSpace, EnergyFunction eFunc)
	{
		sparseTree = rootEdge;
		sparseEnergyFunction = new PartialConformationEnergyFunction(eFunc, problem.confSpace);
		buildDecomposedProblem(sparseTree, fullSpace);
		resMap = ResidueIndexMap.createResidueIndexMap(problem.confSpace);
	}
	
	public void preprocess()
	{
		root.preprocess();
	}
	
	public void buildDecomposedProblem(TreeEdge sparseTree, RCs fullSpace)
	{
		RCTuple emptyConf = new RCTuple();
		root = new Subproblem(fullSpace, sparseTree, resMap);
	}

	public Subproblem getRoot () {
		return root;
	}
	
	public BigInteger subproblemTESS()
	{
		return null;
	}
	

}
